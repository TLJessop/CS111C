package com.Tljessop.VideoCodeAlong;import java.util.*;/** * A class of bags whose entries are stored in a chain of linked nodes. The bag * is never full. *  * @author Frank M. Carrano * @author Timothy M. Henry * @version 5.0 */public final class LinkedBag<T> implements BagInterface<T> {	private Node firstNode; // Reference to first node	private int numberOfEntries;	public LinkedBag() {		firstNode = null;		numberOfEntries = 0;	} // end default constructor	/**	 * Adds a new entry to this bag.	 * 	 * @param newEntry The object to be added as a new entry	 * @return True if the addition is successful, or false if not.	 */	public boolean add(T newEntry) // OutOfMemoryError possible	{		// Add to beginning of chain:		Node newNode = new Node(newEntry);		newNode.next = firstNode; // Make new node reference rest of chain									// (firstNode is null if chain is empty)		firstNode = newNode; // New node is at beginning of chain		numberOfEntries++;		return true;	} // end add	/**	 * Retrieves all entries that are in this bag.	 * 	 * @return A newly allocated array of all the entries in this bag.	 */	public T[] toArray() {		// The cast is safe because the new array contains null entries		@SuppressWarnings("unchecked")		T[] result = (T[]) new Object[numberOfEntries]; // Unchecked cast		int index = 0;		Node currentNode = firstNode;		while ((index < numberOfEntries) && (currentNode != null)) {			result[index] = currentNode.data;			index++;			currentNode = currentNode.next;		} // end while		return result;	} // end toArray	/**	 * Sees whether this bag is empty.	 * 	 * @return True if this bag is empty, or false if not.	 */	public boolean isEmpty() {		return numberOfEntries == 0;	} // end isEmpty	/**	 * Gets the number of entries currently in this bag.	 * 	 * @return The integer number of entries currently in this bag.	 */	public int getCurrentSize() {		return numberOfEntries;	} // end getCurrentSize	/**	 * Removes one unspecified entry from this bag, if possible.	 * 	 * @return Either the removed entry, if the removal was successful, or null.	 */	public T remove() {		T result = null;		if (firstNode != null) {			result = firstNode.data;			firstNode = firstNode.next; // Remove first node from chain			numberOfEntries--;		} // end if		return result;	} // end remove	/**	 * Removes one occurrence of a given entry from this bag, if possible.	 * 	 * @param anEntry The entry to be removed.	 * @return True if the removal was successful, or false otherwise.	 */	public boolean remove(T anEntry) {		boolean result = false;		Node nodeN = getReferenceTo(anEntry);		if (nodeN != null) {			nodeN.data = firstNode.data; // Replace located entry with entry in first node			firstNode = firstNode.next; // Remove first node			numberOfEntries--;			result = true;		} // end if		return result;	} // end remove	/** Removes all entries from this bag. */	public void clear() {		while (!isEmpty())			remove();	} // end clear	/**	 * Counts the number of times a given entry appears in this bag.	 * 	 * @param anEntry The entry to be counted.	 * @return The number of times anEntry appears in this bag.	 */	public int getFrequencyOf(T anEntry) {		int frequency = 0;		int loopCounter = 0;		Node currentNode = firstNode;		while ((loopCounter < numberOfEntries) && (currentNode != null)) {			if (anEntry.equals(currentNode.data)) {				frequency++;			} // end if			loopCounter++;			currentNode = currentNode.next;		} // end while		return frequency;	} // end getFrequencyOf	/**	 * Tests whether this bag contains a given entry.	 * 	 * @param anEntry The entry to locate.	 * @return True if the bag contains anEntry, or false otherwise.	 */	public boolean contains(T anEntry) {		boolean found = false;		Node currentNode = firstNode;		while (!found && (currentNode != null)) {			if (anEntry.equals(currentNode.data))				found = true;			else				currentNode = currentNode.next;		} // end while		return found;	} // end contains	// Locates a given entry within this bag.	// Returns a reference to the node containing the entry, if located,	// or null otherwise.	private Node getReferenceTo(T anEntry) {		boolean found = false;		Node currentNode = firstNode;		while (!found && (currentNode != null)) {			if (anEntry.equals(currentNode.data))				found = true;			else				currentNode = currentNode.next;		} // end while		return currentNode;	} // end getReferenceTo	private class Node {		private T data; // Entry in bag		private Node next; // Link to next node		private Node(T dataPortion) {			this(dataPortion, null);		} // end constructor		private Node(T dataPortion, Node nextNode) {			data = dataPortion;			next = nextNode;		} // end constructor	} // end Node	// for this equals method, two LinkedBags are equal	// if and only if their contents are the same and in	// the same order	// NOTE: this is different from how we implemented it	// in ArrayBag and is really only for an example	// of using linked nodes	@Override	public boolean equals(Object obj) {	    if(obj==null) return false;	    if (obj==this) return true;		if (obj instanceof LinkedBag) {			LinkedBag<T> otherBag = (LinkedBag) obj;			if (numberOfEntries == otherBag.numberOfEntries) {				Node currentNodeThisBag = firstNode;				Node currentNodeOtherBag = otherBag.firstNode;				while (currentNodeThisBag != null && currentNodeOtherBag != null) {					T currentDataThisBag = currentNodeThisBag.data;					T currentDataOtherBag = currentNodeOtherBag.data;					if (!currentDataThisBag.equals(currentDataOtherBag)) {						return false;					}					currentNodeThisBag = currentNodeThisBag.next;					currentNodeOtherBag = currentNodeOtherBag.next;				}				return true;			} else {				return false;			}		} else {			return false;		}	}    //the following methods are my additions    public T removeRandom(){        int postion = ((int) (Math.random() * numberOfEntries) + 1 );        Node currentNode = firstNode;        for (int i = 1; i < postion; i++){            currentNode = currentNode.next;        }        T data = (T) currentNode.data;        remove(data);        return data;    }    public void swap(T firstValue, T swapValue){	    if (this.contains(firstValue) && this.contains(swapValue)){	        Node swapNode1 = this.getReferenceTo(firstValue);	        Node swapNode2 = this.getReferenceTo(swapValue);	        T originalFirst = swapNode1.data;	        swapNode1.data = swapNode2.data;	        swapNode2.data = originalFirst;        }else throw  new IllegalArgumentException("Please give values contained in the list:");    }//	public T getMax(){//		if(firstNode != null) {//			T max = firstNode.data;//			Node currentNode = firstNode;////			for (int i = 1; i <= numberOfEntries; i++) {//				if (currentNode.data.compareTo(max) > 0) {//					max = currentNode.data;//				}//				currentNode = currentNode.next;//////			}////			return max;//		} else return null;//	}	public void addAll(T[] items){		for (int i = 0; i < items.length; i++) {			add(items[i]);		}	}	public void removeAll(T item){		if (firstNode != null){			if (firstNode.data.equals(item)) {				firstNode = firstNode.next;			}			Node beforeNode = firstNode;			while (beforeNode != null) {				if (beforeNode.next != null) {					if (beforeNode.next.data.equals(item)) {						beforeNode.next = beforeNode.next.next;						numberOfEntries--;					}				}				beforeNode = beforeNode.next;			}		}	}	public static void main(String[] args){		LinkedBag<Integer> textBag = new LinkedBag<>();		textBag.add(2);		textBag.add(1);		textBag.add(3);		textBag.add(40);		Integer[] numies = new Integer[4];		numies[0] = 1;		numies[1] =616;		numies[2] = 420;		numies[3] = 69;		textBag.addAll(numies);		System.out.println(Arrays.toString(textBag.toArray()));		textBag.removeAll(2);		System.out.println(Arrays.toString(textBag.toArray()));	}} // end LinkedBag